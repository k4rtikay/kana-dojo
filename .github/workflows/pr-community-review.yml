name: Community Contribution Auto-Review

on:
  pull_request_target:
    types: [opened, synchronize]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  validate-and-merge:
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.title, 'theme') || contains(github.event.pull_request.title, 'fact') || contains(github.event.pull_request.title, 'Theme') || contains(github.event.pull_request.title, 'Fact')

    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}

      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          path: pr-head

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate and process contribution
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const templates = require('./.github/templates/messages.cjs');
            const t = templates.communityReview;

            const prTitle = context.payload.pull_request.title;
            const prTitleLower = prTitle.toLowerCase();
            const prBody = context.payload.pull_request.body || '';
            const prNumber = context.payload.pull_request.number;

            let isValid = false;
            let validationType = null;
            let errors = [];
            let linkedIssue = null;
            let foundIssue = null;

            const isThemeContribution = prTitleLower.includes('theme');
            const isFactContribution = prTitleLower.includes('fact');

            if (!isThemeContribution && !isFactContribution) {
              console.log('Not a community contribution PR');
              return;
            }

            const issueMatch = prBody.match(/[Cc]loses?\s*#(\d+)|[Ff]ixes?\s*#(\d+)/);
            if (issueMatch) {
              linkedIssue = parseInt(issueMatch[1] || issueMatch[2]);
              console.log('Issue already linked: #' + linkedIssue);
            }

            if (!linkedIssue) {
              console.log('No issue linked, searching for matching issue...');
              
              const issuesResponse = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: templates.labels.community,
                state: 'open',
                per_page: 100
              });
              const issues = issuesResponse.data;
              
              if (isThemeContribution) {
                let themeName = null;
                const patterns = [
                  /add\s+(.+?)\s+theme/i,
                  /theme[:\s]+(.+)/i,
                  /feat\(theme\)[:\s]+add\s+(.+)/i
                ];
                
                for (const pattern of patterns) {
                  const match = prTitle.match(pattern);
                  if (match) {
                    themeName = match[1].trim().replace(/theme$/i, '').trim();
                    break;
                  }
                }
                
                if (themeName) {
                  console.log('Looking for theme issue: ' + themeName);
                  for (const issue of issues) {
                    if (issue.title.includes('Add Theme:') && 
                        issue.title.toLowerCase().includes(themeName.toLowerCase())) {
                      foundIssue = issue.number;
                      console.log('Found matching theme issue: #' + foundIssue);
                      break;
                    }
                  }
                }
              } else if (isFactContribution) {
                const factIdMatch = prTitle.match(/#(\d+)/);
                if (factIdMatch) {
                  const factId = factIdMatch[1];
                  console.log('Looking for fact issue: #' + factId);
                  for (const issue of issues) {
                    if (issue.title.includes('Add Japan Fact #' + factId)) {
                      foundIssue = issue.number;
                      console.log('Found matching fact issue: #' + foundIssue);
                      break;
                    }
                  }
                }
              }
            }

            const targetIssue = linkedIssue || foundIssue;

            if (isThemeContribution) {
              validationType = 'theme';
              console.log('Validating theme contribution');
              
              try {
                const themesPath = 'pr-head/features/Preferences/data/themes.ts';
                if (!fs.existsSync(themesPath)) {
                  errors.push('themes.ts file not found in PR');
                } else {
                  const content = fs.readFileSync(themesPath, 'utf8');
                  
                  if (!content.includes('export const themes') && !content.includes('export default')) {
                    errors.push('themes.ts appears to be malformed');
                  }
                  
                  const oklchRegex = /oklch\(\s*[\d.]+%?\s+[\d.]+\s+[\d.]+/g;
                  const oklchMatches = content.match(oklchRegex);
                  if (!oklchMatches || oklchMatches.length === 0) {
                    errors.push('No valid OKLCH colors found');
                  }
                  
                  if (!targetIssue) {
                    errors.push('Could not find a matching community issue for this theme');
                  }
                }
              } catch (e) {
                errors.push('Error reading themes file: ' + e.message);
              }
              
            } else if (isFactContribution) {
              validationType = 'fact';
              console.log('Validating fact contribution');
              
              try {
                const factsPath = 'pr-head/public/japan-facts.json';
                if (!fs.existsSync(factsPath)) {
                  errors.push('japan-facts.json file not found in PR');
                } else {
                  const content = fs.readFileSync(factsPath, 'utf8');
                  
                  try {
                    const facts = JSON.parse(content);
                    
                    if (!Array.isArray(facts)) {
                      errors.push('japan-facts.json should be an array');
                    } else {
                      const nonStrings = facts.filter(function(f) { return typeof f !== 'string'; });
                      if (nonStrings.length > 0) {
                        errors.push('All facts should be strings');
                      }
                    }
                  } catch (parseErr) {
                    errors.push('Invalid JSON: ' + parseErr.message);
                  }
                  
                  if (!targetIssue) {
                    errors.push('Could not find a matching community issue for this fact');
                  }
                }
              } catch (e) {
                errors.push('Error reading facts file: ' + e.message);
              }
            }

            isValid = errors.length === 0;

            if (foundIssue && !linkedIssue) {
              const newBody = prBody + '\n\n---\nü§ñ **Auto-linked:** Closes #' + foundIssue;
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                body: newBody
              });
              console.log('Updated PR body to link issue #' + foundIssue);
            }

            let commentBody;
            if (isValid) {
              let issueNote = '';
              if (foundIssue && !linkedIssue) {
                issueNote = '\n\n' + t.passed.autoDetectedIssue.replace('{issue}', foundIssue);
              } else if (linkedIssue) {
                issueNote = '\n\n' + t.passed.linkedIssue.replace('{issue}', linkedIssue);
              }
              
              const checks = t.passed.checks.map(function(c) { return '- ‚úÖ ' + c; }).join('\n');
              
              commentBody = t.passed.title + '\n\n' +
                t.passed.body.replace('{type}', validationType) + '\n\n' +
                '**Checks passed:**\n' + checks + issueNote + '\n\n' +
                t.passed.footer;
            } else {
              const errorList = errors.map(function(e) { return '- ‚ùå ' + e; }).join('\n');
              commentBody = t.failed.title + '\n\n' +
                t.failed.body.replace('{type}', validationType) + '\n\n' +
                errorList + '\n\n' +
                t.failed.footer;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });

            if (isValid) {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                event: 'APPROVE',
                body: t.approval
              });
              
              try {
                await github.graphql(
                  'mutation($pullRequestId: ID!) { enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: SQUASH }) { pullRequest { autoMergeRequest { enabledAt } } } }',
                  { pullRequestId: context.payload.pull_request.node_id }
                );
                
                console.log('Auto-merge enabled for PR #' + prNumber);
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: t.autoMergeEnabled
                });
              } catch (e) {
                console.log('Could not enable auto-merge: ' + e.message);
              }
            }
